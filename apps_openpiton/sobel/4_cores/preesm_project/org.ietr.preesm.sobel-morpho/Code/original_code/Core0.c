/**
 * @file Core0.c
 * @generated by InstrumentedCPrinter
 * @date Thu Mar 18 18:58:55 CET 2021
 *
 * Code generated for processing element Core0 (ID=0).
 */

#include "preesm_gen.h"
// Core Global Declaration
extern pthread_barrier_t iter_barrier;
extern int stopThreads;

// Core Global Definitions
char Core0[105600]; //  size:= 105600*char
char Shared[206272]; //  size:= 206272*char
char *const Read_YUV_0__display_0__0 = (char*) (Core0+0);  // Read_YUV_0 > display_0 size:= 50688*char
char *const Sobel_0__Dilation_0__0 = (char*) (Core0+50688);  // Sobel_0 > Dilation_0 size:= 28160*char
char *const Dilation_0__Erosion_0__0 = (char*) (Core0+78848);  // Dilation_0 > Erosion_0 size:= 26752*char
char *const Read_YUV_0__Split_0__0 = (char*) (Shared+1760);  // Read_YUV_0 > Split_0 size:= 101376*char
char *const explode_Split_0_output__Sobe__0 = (char*) (Shared+0);  // explode_Split_0_output > Sobel_0 size:= 28864*char
char *const explode_Split_0_output__Sobe__1 = (char*) (Shared+25344);  // explode_Split_0_output > Sobel_1 size:= 28864*char
char *const explode_Split_0_output__Sobe__2 = (char*) (Shared+50688);  // explode_Split_0_output > Sobel_2 size:= 28864*char
char *const explode_Split_0_output__Sobe__3 = (char*) (Shared+76032);  // explode_Split_0_output > Sobel_3 size:= 28864*char
char *const implode_display_0_y__display__0 = (char*) (Shared+104896);  // implode_display_0_y > display_0 size:= 101376*char
char *const Erosion_0__implode_display_0__0 = (char*) (Shared+104896);  // Erosion_0 > implode_display_0_y size:= 25344*char
char *const Erosion_1__implode_display_0__0 = (char*) (Shared+130240);  // Erosion_1 > implode_display_0_y size:= 25344*char
char *const Erosion_2__implode_display_0__0 = (char*) (Shared+155584);  // Erosion_2 > implode_display_0_y size:= 25344*char
char *const Erosion_3__implode_display_0__0 = (char*) (Shared+180928);  // Erosion_3 > implode_display_0_y size:= 25344*char
uchar *const u__u__0 = (uchar*) (Core0+0);  // Read_YUV_0_u > display_0_u size:= 25344*uchar
uchar *const v__v__0 = (uchar*) (Core0+25344);  // Read_YUV_0_v > display_0_v size:= 25344*uchar
uchar *const output__input__0 = (uchar*) (Core0+50688);  // Sobel_0_output > Dilation_0_input size:= 28160*uchar
uchar *const output__input__1 = (uchar*) (Core0+78848);  // Dilation_0_output > Erosion_0_input size:= 26752*uchar
uchar *const y__input__0 = (uchar*) (Shared+1760);  // Read_YUV_0_y > Split_0_input size:= 101376*uchar
uchar *const output_0__input__0 = (uchar*) (Shared+0);  // explode_Split_0_output_output_0 > Sobel_0_input size:= 28864*uchar
uchar *const output_1__input__0 = (uchar*) (Shared+25344);  // explode_Split_0_output_output_1 > Sobel_1_input size:= 28864*uchar
uchar *const output_2__input__0 = (uchar*) (Shared+50688);  // explode_Split_0_output_output_2 > Sobel_2_input size:= 28864*uchar
uchar *const output_3__input__0 = (uchar*) (Shared+76032);  // explode_Split_0_output_output_3 > Sobel_3_input size:= 28864*uchar
uchar *const output__y__0 = (uchar*) (Shared+104896);  // implode_display_0_y_output > display_0_y size:= 101376*uchar
uchar *const output__y_0__0 = (uchar*) (Shared+104896);  // Erosion_0_output > implode_display_0_y_y_0 size:= 25344*uchar
uchar *const output__y_1__0 = (uchar*) (Shared+130240);  // Erosion_1_output > implode_display_0_y_y_1 size:= 25344*uchar
uchar *const output__y_2__0 = (uchar*) (Shared+155584);  // Erosion_2_output > implode_display_0_y_y_2 size:= 25344*uchar
uchar *const output__y_3__0 = (uchar*) (Shared+180928);  // Erosion_3_output > implode_display_0_y_y_3 size:= 25344*uchar
uint64_t dumpedTimes[53]; //  size:= 53*uint64_t
int nbExec[53]; //  size:= 53*int
int idx;

void *computationThread_Core0(void *arg){
	if (arg != NULL) {
		printf("Warning: expecting NULL arguments\n");
	}
	// Initialisation(s)
	initReadYUV(352/*width*/,288/*height*/); // Read_YUV_0
	yuvDisplayInit(0/*id*/,352/*width*/,288/*height*/); // display_0
	initNbExec(nbExec,53/*nbDump*/); // 

	// Begin the execution loop
#ifdef LOOP_SIZE // Case of a finite loop
	int index;
	for(index=0;index<LOOP_SIZE;index++){
#else // Default case of an infinite loop
	while(1){
#endif
		pthread_barrier_wait(&iter_barrier);
		if(stopThreads){
			pthread_exit(NULL);
		}
		dumpTime(0/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+1); idx++){
			readYUV(352/*width*/,288/*height*/,y__input__0,u__u__0,v__v__0); // Read_YUV_0
		}
		dumpTime(1/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+2); idx++){
			split(4/*nbSlice*/,352/*width*/,288/*height*/,5/*overlap*/,y__input__0,NULL); // Split_0
		}
		dumpTime(2/*globalID*/,dumpedTimes); // 
		*(nbExec+3) = 0;
		sendStart(0, 3); // Core0 > Core3: NULL
		dumpTime(3/*globalID*/,dumpedTimes); // 
		*(nbExec+4) = 0;
		sendEnd(); // Core0 > Core3: NULL
		dumpTime(4/*globalID*/,dumpedTimes); // 
		*(nbExec+5) = 0;
		receiveStart(); // Core3 > Core0: explode_Split_0_output__Sobe__0
		dumpTime(5/*globalID*/,dumpedTimes); // 
		*(nbExec+6) = 0;
		receiveEnd(3, 0); // Core3 > Core0: explode_Split_0_output__Sobe__0
		dumpTime(6/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+7); idx++){
			sobel(352/*width*/,82/*height*/,output_0__input__0,output__input__0); // Sobel_0
		}
		dumpTime(7/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+8); idx++){
			dilation(80/*height*/,352/*width*/,2/*window*/,output__input__0,output__input__1); // Dilation_0
		}
		dumpTime(8/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+9); idx++){
			erosion(76/*height*/,352/*width*/,2/*window*/,output__input__1,output__y_0__0); // Erosion_0
		}
		dumpTime(9/*globalID*/,dumpedTimes); // 
		*(nbExec+10) = 0;
		sendStart(0, 3); // Core0 > Core3: Erosion_0__implode_display_0__0
		dumpTime(10/*globalID*/,dumpedTimes); // 
		*(nbExec+11) = 0;
		sendEnd(); // Core0 > Core3: Erosion_0__implode_display_0__0
		dumpTime(11/*globalID*/,dumpedTimes); // 
		*(nbExec+12) = 0;
		receiveStart(); // Core3 > Core0: implode_display_0_y__display__0
		dumpTime(12/*globalID*/,dumpedTimes); // 
		*(nbExec+13) = 0;
		receiveEnd(3, 0); // Core3 > Core0: implode_display_0_y__display__0
		dumpTime(13/*globalID*/,dumpedTimes); // 
		for(idx=0; idx<*(nbExec+14); idx++){
			yuvDisplay(0/*id*/,output__y__0,u__u__0,v__v__0); // display_0
		}
		dumpTime(14/*globalID*/,dumpedTimes); // 
		pthread_barrier_wait(&iter_barrier);
		writeTime(dumpedTimes,53/*nbDump*/, nbExec);
	}
	return NULL;
}

